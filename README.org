#+TITLE: LLM Function Calling Pattern - Two Actor System
#+PROPERTY: header-args :mkdirp yes :comments both

[[https://img.shields.io/badge/language-Guile%20Scheme-blue.svg]]
[[https://img.shields.io/badge/license-MIT-green.svg]]
[[https://img.shields.io/badge/platform-FreeBSD%20%7C%20Linux-lightgrey.svg]]

A Guile Scheme implementation demonstrating the interaction between an Application (Actor 1) and an LLM Provider (Actor 2) for function calling capabilities.

#+begin_src mermaid :file llm-function-calling-flow.png :exports results
sequenceDiagram
    participant User
    participant App as Application Actor
    participant LLM as LLM Actor
    participant Registry as Function Registry
    
    Note over User,Registry: Setup Phase
    App->>Registry: Register Functions
    Registry-->>App: Functions Available
    
    Note over User,Registry: Interaction Phase
    User->>App: Send Prompt
    App->>App: Add Function Definitions
    App->>LLM: Prompt + Available Functions
    
    Note over LLM: Decision Point
    alt Needs Function
        LLM->>App: Request Function Call<br/>(name + arguments)
        App->>Registry: Lookup Function
        Registry-->>App: Function Reference
        App->>App: Execute Function
        App->>LLM: Return Result
        LLM->>LLM: Process Result
        LLM->>App: Final Answer
    else Direct Answer
        LLM->>App: Final Answer
    end
    
    App->>User: Response
    
    Note over User,Registry: Optional: Multiple Function Calls
    opt Additional Tools Needed
        LLM->>App: Request Another Function
        App->>App: Execute
        App->>LLM: Result
        Note right of LLM: Loop until complete
    end
#+end_src

** Overview

This project implements a two-actor pattern for LLM function calling, providing:
- Clear separation between application logic and LLM reasoning
- Asynchronous message passing between actors
- Extensible function registry
- Thread-safe communication channels

** Architecture

The system consists of two main actors:

1. *Application Actor*: Manages function definitions, executes requested functions, and handles results
2. *LLM Actor*: Processes prompts, decides whether to call functions or respond directly, and generates final answers

Communication happens through message queues with defined message types for each phase of interaction.

** Requirements

- GNU Guile 3.0 or later
- SRFI modules (srfi-1, srfi-9)
- ice-9 modules (match, format, threads)

** Installation

#+begin_src bash
git clone https://github.com/aygp-dr/llm-function-actors
cd llm-function-actors
#+end_src

** Usage

*** Run the simulator
#+begin_src bash
gmake run
#+end_src

*** Run demo examples
#+begin_src bash
gmake demo
# or directly:
./examples/function-calling-demo.scm
#+end_src

*** Available Functions

The simulator comes with two built-in functions:
- ~calculate~: Adds two numbers
- ~get-time~: Returns current timestamp

Additional functions can be registered:
#+begin_src scheme
(register-function! 'my-function
                    (lambda (arg1 arg2)
                      ;; function implementation
                      result))
#+end_src

** Project Structure

#+begin_example
.
├── SETUP.org           # Original design document
├── README.org          # This file
├── Makefile            # Build automation
├── src/
│   └── function-calling-simulator.scm  # Main simulator
├── examples/
│   └── function-calling-demo.scm       # Usage examples
└── docs/
    ├── function-flow.org               # Sequence diagrams
    └── pattern-analysis.org            # Architecture analysis
#+end_example

** Message Flow

1. Application sends initial prompt with function definitions
2. LLM analyzes prompt and decides action
3. If function needed: LLM requests function execution
4. Application executes function and returns result
5. LLM incorporates result and generates final answer

** Extending the System

To add new capabilities:

1. Register new functions using ~register-function!~
2. Extend message types for new interaction patterns
3. Add error handling for production use
4. Implement timeout mechanisms for long-running functions

** License

This project is part of the aygp-dr repository.