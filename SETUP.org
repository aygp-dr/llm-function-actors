* LLM Function Calling Pattern - Two Actor System
:PROPERTIES:
:CATEGORY: System Architecture
:TAGS: LLM, Function-Calling, Actor-Model
:END:

** Architecture Overview

This pattern demonstrates the interaction between an Application (Actor 1) and an LLM Provider (Actor 2) for function calling capabilities.

** System Flow

#+begin_src mermaid :file function-calling-flow.png
sequenceDiagram
    participant App as Application
    participant LLM as LLM Provider
    
    App->>LLM: Initial Request (Prompt + Function Definitions)
    LLM->>LLM: Decide Response Strategy
    LLM->>App: Completion (Function Name + Arguments)
    App->>App: Parse Response & Execute Function
    App->>LLM: Function Result + Continuation Prompt
    LLM->>LLM: Decide Next Action
    LLM->>App: Final Answer
    
    Note over App,LLM: Loop possible for multiple function calls
#+end_src

** Guile Scheme Simulator

#+begin_src scheme :tangle ./src/function-calling-simulator.scm :mkdirp yes
#!/usr/bin/env guile
!#

(use-modules (ice-9 match)
             (ice-9 format)
             (srfi srfi-1)
             (srfi srfi-9))

;; Define message types
(define-record-type <message>
  (make-message type content sender)
  message?
  (type message-type)
  (content message-content)
  (sender message-sender))

;; Define function registry
(define function-registry '())

(define (register-function! name fn)
  "Register a function that can be called by the LLM"
  (set! function-registry 
        (assoc-set! function-registry name fn)))

;; Actor: Application
(define (application-actor inbox outbox)
  "Application actor that sends prompts and executes functions"
  (let loop ((state 'idle))
    (match (receive-message inbox)
      [($ <message> 'start prompt _)
       ;; Send initial prompt with function definitions
       (send-message outbox 
                     (make-message 'prompt 
                                   `((prompt . ,prompt)
                                     (functions . ,(map car function-registry)))
                                   'application))
       (loop 'waiting-for-response)]
      
      [($ <message> 'function-call (name . args) 'llm)
       ;; Execute requested function
       (let* ((fn (assoc-ref function-registry name))
              (result (if fn
                          (apply fn args)
                          `(error . ,(format #f "Unknown function: ~a" name)))))
         (send-message outbox
                       (make-message 'function-result
                                     `((function . ,name)
                                       (result . ,result))
                                     'application))
         (loop 'waiting-for-final))]
      
      [($ <message> 'final-answer answer 'llm)
       (format #t "Final Answer: ~a~%" answer)
       (loop 'complete)]
      
      [msg
       (format #t "Application: Unexpected message ~a in state ~a~%" msg state)
       (loop state)])))

;; Actor: LLM Provider
(define (llm-actor inbox outbox)
  "LLM actor that processes prompts and decides on actions"
  (let loop ((context '()))
    (match (receive-message inbox)
      [($ <message> 'prompt content 'application)
       (let ((prompt (assoc-ref content 'prompt))
             (functions (assoc-ref content 'functions)))
         ;; Simulate decision making
         (cond
           [(string-contains prompt "calculate")
            ;; Decide to call a function
            (send-message outbox
                          (make-message 'function-call
                                        '(calculate . (5 3))
                                        'llm))]
           [else
            ;; Direct response
            (send-message outbox
                          (make-message 'final-answer
                                        "I'll help you with that."
                                        'llm))])
         (loop `((prompt . ,prompt) . ,context)))]
      
      [($ <message> 'function-result content 'application)
       (let ((result (assoc-ref content 'result)))
         ;; Incorporate function result and generate final answer
         (send-message outbox
                       (make-message 'final-answer
                                     (format #f "Based on the calculation, the result is: ~a" result)
                                     'llm))
         (loop `((last-result . ,result) . ,context)))]
      
      [msg
       (format #t "LLM: Unexpected message ~a~%" msg)
       (loop context)])))

;; Message passing infrastructure
(define (make-channel)
  "Create a bidirectional channel"
  (cons (make-queue) (make-queue)))

(define (send-message channel msg)
  "Send a message to a channel"
  (enqueue! (car channel) msg))

(define (receive-message channel)
  "Blocking receive from a channel"
  (let loop ()
    (if (queue-empty? (cdr channel))
        (begin (usleep 1000) (loop))
        (dequeue! (cdr channel)))))

;; Example functions available to LLM
(register-function! 'calculate
                    (lambda (a b)
                      (+ a b)))

(register-function! 'get-time
                    (lambda ()
                      (strftime "%Y-%m-%d %H:%M:%S" (localtime (current-time)))))

;; Simulation runner
(define (run-simulation prompt)
  "Run a complete function calling simulation"
  (let ((app-to-llm (make-channel))
        (llm-to-app (cons (cdr app-to-llm) (car app-to-llm))))
    
    ;; Start actors in separate threads
    (call-with-new-thread
     (lambda ()
       (application-actor llm-to-app app-to-llm)))
    
    (call-with-new-thread
     (lambda ()
       (llm-actor app-to-llm llm-to-app)))
    
    ;; Initiate conversation
    (send-message app-to-llm
                  (make-message 'start prompt 'user))
    
    ;; Wait for completion
    (sleep 2)))

;; Queue implementation
(define (make-queue)
  (cons '() '()))

(define (enqueue! q item)
  (set-cdr! q (cons item (cdr q))))

(define (dequeue! q)
  (if (null? (car q))
      (begin
        (set-car! q (reverse (cdr q)))
        (set-cdr! q '())))
  (let ((item (caar q)))
    (set-car! q (cdar q))
    item))

(define (queue-empty? q)
  (and (null? (car q)) (null? (cdr q))))
#+end_src

** Usage Example

#+begin_src scheme :tangle ./examples/function-calling-demo.scm :mkdirp yes
#!/usr/bin/env guile
!#

(load "../src/function-calling-simulator.scm")

;; Register additional functions
(register-function! 'weather
                    (lambda (city)
                      (format #f "22Â°C and sunny in ~a" city)))

(register-function! 'search
                    (lambda (query)
                      `((results . (("Title 1" . "Content 1")
                                    ("Title 2" . "Content 2"))))))

;; Run simulations
(display "=== Calculation Request ===\n")
(run-simulation "Please calculate 5 + 3 for me")

(sleep 1)

(display "\n=== Direct Response ===\n")
(run-simulation "Hello, how are you?")
#+end_src

** Pattern Analysis

*** Key Components

#+begin_src mermaid :file actor-components.png :mkdirp t
graph TB
    subgraph "Application Actor"
        A1[Function Registry]
        A2[Message Handler]
        A3[Function Executor]
        A1 --> A3
        A2 --> A3
    end
    
    subgraph "LLM Actor"
        L1[Context Manager]
        L2[Decision Engine]
        L3[Response Generator]
        L1 --> L2
        L2 --> L3
    end
    
    subgraph "Communication Layer"
        C1[Message Queue]
        C2[Channel Abstraction]
        C1 --> C2
    end
    
    A3 -.-> C2
    L3 -.-> C2
    C2 -.-> A2
    C2 -.-> L2
#+end_src

*** Message Flow States

1. **Initial State**: Application idle, LLM waiting
2. **Prompt Phase**: Application sends prompt + function definitions
3. **Decision Phase**: LLM analyzes and decides action
4. **Function Call Phase**: LLM requests function execution
5. **Execution Phase**: Application runs function locally
6. **Result Phase**: Application returns function output
7. **Completion Phase**: LLM generates final answer

*** Benefits of Two-Actor Pattern

- **Separation of Concerns**: Clear boundaries between application logic and LLM reasoning
- **Asynchronous Operation**: Non-blocking message passing
- **Extensibility**: Easy to add new functions to registry
- **Testability**: Each actor can be tested independently
- **Provider Agnostic**: Works with any LLM that supports function calling

** Implementation Notes

*** Thread Safety
The queue implementation provides basic thread safety through Guile's built-in primitives. For production use, consider using Guile's thread-safe data structures.

*** Error Handling
The simulator includes basic error handling for unknown functions. Extend this for production use with:
- Timeout mechanisms
- Retry logic
- Error propagation
- Graceful degradation

*** Performance Considerations
- Message passing overhead is minimal for typical LLM latencies
- Function registry lookup is O(n); consider hash tables for large registries
- Queue operations are amortized O(1)
